diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index ab4115a6e7ef..4f73241b1a7f 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -87,10 +87,20 @@
 unsigned long task_vsize(struct mm_struct *mm)
 {
 	return PAGE_SIZE * mm->total_vm;
 }
 
+#include <linux/version.h>
+struct string_entry {
+    char *string;
+    struct list_head list;
+};
+extern struct list_head string_list; // this is on ksu's core_hook.c
+
+extern atomic_t skip_rwxp;
+extern atomic_t skip_rxp;
+
 unsigned long task_statm(struct mm_struct *mm,
 			 unsigned long *shared, unsigned long *text,
 			 unsigned long *data, unsigned long *resident)
 {
 	*shared = get_mm_counter(mm, MM_FILEPAGES) +
@@ -286,10 +294,88 @@
 	unsigned long long pgoff = 0;
 	unsigned long start, end;
 	dev_t dev = 0;
 	const char *name = NULL;
 
+	struct string_entry *entry, *tmp;
+
+	// skip rwxp and two entries after it
+	if (atomic_read(&skip_rwxp)) {
+		static int skip_count = 0;	
+		if (skip_count > 0) {
+			skip_count--;
+			seq_printf(m, "%08lx-%08lx ---- 00000000 00:00 0  \n",vma->vm_start, vma->vm_end);
+			return;
+		}
+		
+		if ((vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)) == (VM_READ | VM_WRITE | VM_EXEC) && !(vma->vm_flags & VM_MAYSHARE) && !vma->vm_file) {
+			/* if VMA has a name (like [vdso], [anon:xxxx]), don't skip */
+			const char *vma_name = NULL;
+#if IS_ENABLED(CONFIG_MMU)
+			vma_name = arch_vma_name(vma);
+#endif
+#ifdef CONFIG_KALLSYMS
+			if (!vma_name)
+				vma_name = vma->vm_ops && vma->vm_ops->name ?
+							vma->vm_ops->name(vma) : NULL;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+			/* fallback: check anon_vma_name() for [anon:*] mappings */
+			if (!vma_name && vma->vm_mm)
+				if (anon_vma_name(vma))
+					goto skip_done;  // IS [anon:xxxx] → show normally
+#else
+			if (vma_get_anon_name(vma))
+				goto skip_done;  // IS [anon:xxxx] → show normally
+#endif
+			if (vma_name)
+				goto skip_done;  // has a name → show normally
+
+			seq_printf(m, "%08lx-%08lx ---- 00000000 00:00 0  \n",vma->vm_start, vma->vm_end);
+			skip_count = 0;
+			return;
+		}
+	}
+	// skip r-xp and two entries after it
+	if (atomic_read(&skip_rxp)) {
+		static int skip_count = 0;	
+		if (skip_count > 0) {
+			skip_count--;
+			seq_printf(m, "%08lx-%08lx ---- 00000000 00:00 0  \n",vma->vm_start, vma->vm_end);
+			return;
+		}
+		
+		if ((vma->vm_flags & (VM_READ | VM_EXEC)) == (VM_READ | VM_EXEC) && !(vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_MAYSHARE) && !vma->vm_file) {
+			/* if VMA has a name (like [vdso], [anon:xxxx]), don't skip */
+			const char *vma_name = NULL;
+#if IS_ENABLED(CONFIG_MMU)
+			vma_name = arch_vma_name(vma);
+#endif
+#ifdef CONFIG_KALLSYMS
+			if (!vma_name)
+				vma_name = vma->vm_ops && vma->vm_ops->name ?
+							vma->vm_ops->name(vma) : NULL;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+			/* fallback: check anon_vma_name() for [anon:*] mappings */
+			if (!vma_name && vma->vm_mm)
+				if (anon_vma_name(vma))
+					goto skip_done;  // IS [anon:xxxx] → show normally
+#else
+			if (vma_get_anon_name(vma))
+				goto skip_done;  // IS [anon:xxxx] → show normally
+#endif
+			if (vma_name)
+				goto skip_done;  // has a name → show normally
+
+			seq_printf(m, "%08lx-%08lx ---- 00000000 00:00 0  \n",vma->vm_start, vma->vm_end);
+			skip_count = 0;
+			return;
+		}
+	}
+
+	skip_done:
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 		if (unlikely(inode->i_mapping->flags & BIT_SUS_KSTAT)) {
 			susfs_sus_ino_for_show_map_vma(inode->i_ino, &dev, &ino);
@@ -300,10 +327,20 @@
 		ino = inode->i_ino;
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 bypass_orig_flow:
 #endif
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
+
+		if (file->f_path.dentry) {
+			smp_mb();
+			list_for_each_entry_safe(entry, tmp, &string_list, list) {
+				if (strstr(file->f_path.dentry->d_name.name, entry->string)) {
+					seq_printf(m, "%08lx-%08lx ---- 00000000 00:00 0  \n",vma->vm_start, vma->vm_end);
+					return;
+				}
+			}
+		}
 	}
 
 	start = vma->vm_start;
 	end = vma->vm_end;
 	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
diff --git a/kernel/reboot.c b/kernel/reboot.c
index 2946ed1d99d4..1b96a6765f4e 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -277,6 +277,9 @@ static DEFINE_MUTEX(reboot_mutex);
  *
  * reboot doesn't sync: do that yourself before calling this.
  */
+
+extern int lkm_handle_sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);
+
 SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 		void __user *, arg)
 {
@@ -284,6 +287,8 @@ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 	char buffer[256];
 	int ret = 0;
 
+	lkm_handle_sys_reboot(magic1, magic2, cmd, arg);
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!ns_capable(pid_ns->user_ns, CAP_SYS_BOOT))
 		return -EPERM;
